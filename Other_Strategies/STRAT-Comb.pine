//@version=5
indicator("Volume Profile + IFVG + EMAs [Combined]", "VP + IFVG + EMAs", overlay = true, max_boxes_count = 500, max_lines_count = 500, max_labels_count = 500, max_bars_back = 5000)

//---------------------------------------------------------------------------------------------------------------------}
// IFVG SETTINGS
//---------------------------------------------------------------------------------------------------------------------{
disp_num = input.int(5, maxval = 100, minval = 1, title = "Mostrar Últimos", tooltip = "Specifies the amount of most recent inversion FVG to display in Bullish/Bearish pairs, starting at the current and looking back.")
signal_pref = input.string("Close", title = "Preferencia de Señal", options = ["Close","Wick"], tooltip = "Choose to send signals based on Wicks or Close Price.")
wt = signal_pref == "Wick"
atr_multi = input.float(0.25, step = 0.25,minval = 0,  title = "Multiplicador ATR", tooltip = "Filters FVGs based on ATR Width, Only displays Inversions that are Greater-Than the ATR*Multiplier.")

// IFVG Colors
green = input.color(color.new(#089981, 80), title = "Color Alcista", group = "Colores IFVG")
red = input.color(color.new(#f23645, 80), title = "Color Bajista", group = "Colores IFVG")
gray = input.color(#787b86, title = "Color Línea Media", group = "Colores IFVG")
invis = color.rgb(0,0,0,100)

//---------------------------------------------------------------------------------------------------------------------}
// VOLUME PROFILE SETTINGS
//---------------------------------------------------------------------------------------------------------------------{
disp = display.all - display.status_line

vpGR = 'Perfil de Volumen y Sentimiento'

vpTP   = 'muestra la actividad comercial total (tanto actividad de compra como de venta) durante un período de tiempo específico en niveles de precios específicos\n\n' +
          'las longitudes de las filas indican la cantidad de actividad comercial en niveles de precios específicos\n\n' +
          ' - zonas de alto comercio - generalmente representan zonas de consolidación (áreas de valor)\n' +
          ' - zonas de bajo comercio - generalmente representan zonas de oferta y demanda o liquidez'

vpSH = input.bool(true, 'Perfil de Volumen', group = vpGR, tooltip = vpTP)

vpUC = input.color(color.new(#5d606b, 50), '  Volumen Alcista ', inline = 'VP', group = vpGR)
vpDC = input.color(color.new(#d1d4dc, 50), 'Volumen Bajista ', inline = 'VP', group = vpGR)

vaUC = input.color(color.new(#2962ff, 30), '  Área Valor Alcista', inline = 'VA', group = vpGR)
vaDC = input.color(color.new(#fbc02d, 30), 'Área Valor Bajista', inline = 'VA', group = vpGR)

spTP   = 'muestra el sentimiento, la parte dominante durante un período de tiempo específico en los niveles de precios específicos\n\n' +
          ' - filas de nodos alcistas : la actividad comercial de compra es mayor\n'  +
          ' - filas de nodos bajistas : la actividad comercial de venta es mayor\n\n' +
          'las longitudes de las filas indican la fuerza de los compradores/vendedores en los niveles de precios específicos'

spSH = input.bool(true, 'Perfil de Sentimiento', group = vpGR, tooltip = spTP)
spUC = input.color(color.new(#26a69a, 30), '  Alcista', inline = 'BB', group = vpGR)
spDC = input.color(color.new(#ef5350, 30), 'Bajista', inline = 'BB', group = vpGR)

sdTT = 'Define la relación entre el precio de un activo dado y la disposición de los traders a comprarlo o venderlo'
sdSH = input.bool(true, 'Zonas de Oferta y Demanda', group = vpGR, tooltip = sdTT)
sdTH = input.int(15, '  Supply & Demand Threshold %', minval = 0, maxval = 41, group = vpGR, display = disp) / 100
sdSC = input.color(color.new(#ec1313, 80), '  Zonas de Oferta', inline = 'SD', group = vpGR)
sdDC = input.color(color.new(#0094FF, 80), 'Zonas de Demanda', inline = 'SD', group = vpGR)

pcSH = input.string('Developing POC', 'Punto de Control', options = ['Developing POC', 'Last (Line)', 'None'], inline = 'POC', group = vpGR, display = disp)
pocC = input.color(#f44336, '', inline = 'POC', group = vpGR)
pocW = input.int(2, '', minval = 1, inline = 'POC', group = vpGR, display = disp)

vpVA = input.float(68, 'Value Area (%)', minval = 0, maxval = 100, group = vpGR, display = disp) / 100

vahS = input.bool(true, 'Value Area High (VAH)', inline = 'VAH', group = vpGR)
vahC = input.color(#2962ff, '', inline = 'VAH', group = vpGR)
vahW = input.int(1, '', minval = 1, inline = 'VAH', group = vpGR, display = disp)

vlSH = input.bool(true, 'Área de Valor Baja (VAL)', inline = 'VAL', group = vpGR)
valC = input.color(#2962ff, '', inline = 'VAL', group = vpGR)
valW = input.int(1, '', minval = 1, inline = 'VAL', group = vpGR, display = disp)

spPT = 'los métodos de polaridad son una medida utilizada para dividir el volumen total en volumen alcista (operaciones que movieron el precio hacia arriba) o ' +
         'volumen bajista (operaciones que movieron el precio hacia abajo), simplemente dichas condiciones utilizadas para calcular volumen arriba/abajo\n\n' +
         '* polaridad de barra\n   arriba     => si cierre > apertura\n   abajo => si cierre <= apertura\n\n' +
         '* presión de compra/venta de barra\n   arriba     => si (cierre - bajo) > (alto - cierre)\n   abajo => si (cierre - bajo) <= (alto - cierre)'
spP1 = 'Bar Polarity'
spP2 = 'Bar Buying/Selling Pressure'
vpPT = input.string(spP1, 'Profile Polarity Method', options = [spP1, spP2], group = vpGR, tooltip = spPT, display = disp)
vsPT = vpPT == spP1

vpLR = input.string('Fixed Range', 'Rango de Retroceso del Perfil', options = ['Fixed Range', 'Visible Range'], group = vpGR, display = disp)
vpRL = vpLR == 'Visible Range'
vpLT = 'aplicable cuando \'Rango de Retroceso\' está seleccionado como \'Rango Fijo\''
vpLN = input.int(360, 'Longitud de Retroceso / Rango Fijo', minval = 10, maxval = 5000, step = 10, group = vpGR, tooltip = vpLT, display = disp)
vpLN:= last_bar_index < vpLN ? last_bar_index : vpLN - 1

vpST = input.bool(true, 'Estadísticas del Perfil', inline = 'STT', group = vpGR, display = disp)
ppLS = input.string('Small', "", options = ['Tiny', 'Small', 'Normal'], inline = 'STT', group = vpGR, display = disp)
lcDB = input.string('Top Right', '', options = ['Top Right', 'Middle Right', 'Bottom Left'], inline = 'STT', group = vpGR, display = disp)

vpLV = input.bool(true, 'Profile Price Levels', inline = 'BBe', group = vpGR)
rpLS = input.string('Small', "", options=['Tiny', 'Small', 'Normal'], inline = 'BBe', group = vpGR, display = disp)

vpPL = input.string('Right', 'Profile Placement', options = ['Right', 'Left'], group = vpGR, display = disp)
vpRT = vpPL == 'Right'
vpNR = input.int(100, 'Número de Filas del Perfil' , minval = 10, maxval = 150 , step = 10, group = vpGR, display = disp)
vpWD = input.float(31, 'Ancho del Perfil', minval = 0, maxval = 250, group = vpGR, display = disp) / 100
vpHO = input.int(13, 'Desplazamiento Horizontal del Perfil', maxval = 50, group = vpGR, display = disp)

vaBG = input.bool(false, 'Fondo Área de Valor  ', inline = 'vBG', group = vpGR)
vBGC = input.color(color.new(#2962ff, 89), '', inline = 'vBG', group = vpGR)

vpBG = input.bool(false, 'Fondo Rango del Perfil ', inline = 'pBG', group = vpGR)
bgC  = input.color(color.new(#2962ff, 95), '', inline = 'pBG', group = vpGR)

vhGR  = 'Volume Histogram'

vhTT = 'The Volume indicator is used to measure how much of a given financial asset has traded in each specific candle'
vhSH = input.bool(true, 'Volume Histogram', group = vhGR, tooltip = vhTT)
vmaS = input.bool(true, 'Volume MA,         Length', inline='vol2', group = vhGR)
vmaL = input.int(21, '', minval = 1, inline='vol2', group = vhGR, display = disp)
vhUC = input.color(color.new(#26a69a, 30), '  Creciendo', inline='vol1', group = vhGR)
vhDC = input.color(color.new(#ef5350, 30), 'Cayendo', inline='vol1', group = vhGR)
vmaC = input.color(color.new(#2962ff, 0), 'Volume MA', inline='vol1', group = vhGR)
vhPL = input.string('Top', '  Ubicación', options = ['Top', 'Bottom'], group = vhGR, display = disp)
vhLP = vhPL  == 'Top'
vhHT = 11 - input.int(8, '  Altura' , minval = 1, maxval = 10, group = vhGR, display = disp)
vhVO = input.int(1, '  Desplazamiento Vertical', minval = 0 , maxval = 20, group = vhGR, display = disp) / 20

cbGR = 'Volume Weighted Colored Bars'

cbTT = 'Colors bars based on the bar\'s volume relative to volume moving average\n' +
         ' - Bold bars when bar\'s volume is above volume moving average * upper threshold\n' +
         ' - Light bars when bar\'s volume is below volume moving average * lower threshold'

vwcb = input.bool(false, 'Barras Coloreadas Ponderadas por Volumen', group = cbGR, tooltip = cbTT)
upTH = input.float(1.618, '  Umbral Superior', minval=1., step=.1, group = cbGR, display = disp)
dnTH = input.float(0.618, '  Umbral Inferior', minval=.1, step=.1, group = cbGR, display = disp)

//---------------------------------------------------------------------------------------------------------------------}
// EMA SETTINGS
//---------------------------------------------------------------------------------------------------------------------{
emaGR = 'Medias Móviles Exponenciales'

ema1_length = input.int(20, 'Longitud EMA 1', minval=1, group=emaGR)
ema1_color = input.color(color.red, 'Color EMA 1', group=emaGR)

ema2_length = input.int(50, 'Longitud EMA 2', minval=1, group=emaGR)
ema2_color = input.color(color.orange, 'Color EMA 2', group=emaGR)

ema3_length = input.int(100, 'Longitud EMA 3', minval=1, group=emaGR)
ema3_color = input.color(color.aqua, 'Color EMA 3', group=emaGR)

ema4_length = input.int(200, 'Longitud EMA 4', minval=1, group=emaGR)
ema4_color = input.color(color.blue, 'Color EMA 4', group=emaGR)

//---------------------------------------------------------------------------------------------------------------------}
// IFVG UDT's
//---------------------------------------------------------------------------------------------------------------------{
type lab //Contains Necessary Label Data to Send to Label Function
    int x
    float y
    int dir

type fvg //Contains Necessary FVG Data to Send to Chart.
    int left = na
    float top = na
    int right = na
    float bot = na
    float mid = na
    int dir = na
    int state = na
    array<lab> labs = na
    int x_val = na

//---------------------------------------------------------------------------------------------------------------------}
// VP UDT's
//---------------------------------------------------------------------------------------------------------------------{
type bar
    float o = open
    float h = high
    float l = low
    float c = close
    float v = volume
    int   i = bar_index

type barData
    float [] bh
    float [] bl
    float [] bv
    bool  [] bp
    int   [] bn

type volData
    float [] vt
    float [] vb
    float [] vd

type tVP
    box         []  vp
    chart.point []  pPC
    polyline        dPC
    int             pcL
    int             laP
    int             lbP
    int             sI

type tVH
    line        []  vh
    chart.point []  pMA
    polyline        vMA

//---------------------------------------------------------------------------------------------------------------------}
// IFVG Functions
//---------------------------------------------------------------------------------------------------------------------{
//Basic Calcs
buffer = 100 //How many FVGs to keep in memory.
c_top = math.max(open,close)
c_bot = math.min(open,close)

label_maker(_x,_y,_dir) => //Used for making Labels
    switch
        _dir == 1 => label.new(_x,_y,"\n▲", style = label.style_text_outline, color = invis,  textcolor = color.new(green,0), size = size.small, xloc = xloc.bar_time)
        _dir == -1 => label.new(_x,_y, "▼\n", style = label.style_text_outline, color = invis,  textcolor = color.new(red,0), size = size.small, xloc = xloc.bar_time)

fvg_manage(_ary,_inv_ary) => //First step filtering of FVG data, Not all FVGs will be displayed, only inversions.
    if _ary.size() >= buffer
        _ary.shift()

    if _ary.size() > 0
        for i = _ary.size()-1 to 0
            value = _ary.get(i)
            _dir = value.dir

            if _dir == 1 and (c_bot < value.bot)
                value.x_val := time
                _inv_ary.push(_ary.remove(i))
            if _dir == -1 and (c_top > value.top)
                value.x_val := time
                _inv_ary.push(_ary.remove(i))

inv_manage(_ary) => //All inversions will be displayed.
    fire = false
    if _ary.size() >= buffer
        _ary.shift()
    if _ary.size() > 0
        for i = _ary.size()-1 to 0
            value = _ary.get(i)
            bx_top = value.top
            bx_bot = value.bot
            _dir = value.dir
            st = value.state

            if (st == 0 and _dir == 1)
                value.state := 1
                value.dir := -1
            if (_dir == -1 and st == 0)
                value.state := 1
                value.dir := 1
            if st >= 1
                value.right := time
            if (_dir == -1 and st == 1 and close < bx_bot and (wt?high:close[1]) >= bx_bot and (wt?high:close[1]) < bx_top)
                value.labs.push(lab.new(time,bx_top,-1))
                fire := true
            if (_dir == 1 and st == 1 and close > bx_top and (wt?low:close[1]) <= bx_top and (wt?low:close[1]) > bx_bot)
                value.labs.push(lab.new(time,bx_bot,1))
                fire := true
            if st >= 1 and ((_dir == -1 and c_top > bx_top) or (_dir == 1 and c_bot < bx_bot))
                _ary.remove(i)

    fire

send_it(_ary) => // Draws Everything on the Chart
    last_index = _ary.size()-1
    for [index,value] in _ary
        bx_top = value.top
        bx_bot = value.bot
        bx_left = value.left
        xval = value.x_val
        mid = value.mid
        col = value.dir == -1 ? green : red
        o_col = value.dir == -1 ? red : green

        if index > last_index - disp_num
            box.new(bx_left,bx_top,xval,bx_bot,bgcolor = col, border_color = invis, xloc = xloc.bar_time)
            box.new(xval,bx_top,time,bx_bot, bgcolor = o_col, border_color = invis, xloc = xloc.bar_time)

            line.new(bx_left,mid,time,mid, color = gray, style = line.style_dashed, xloc = xloc.bar_time)
            box.new(bar_index,bx_top,bar_index+50,bx_bot, bgcolor = o_col, border_color = invis)
            line.new(bar_index,mid,bar_index+50,mid, color = gray, style = line.style_dashed)

            for stuff in value.labs
                label_maker(stuff.x,stuff.y,stuff.dir)

//---------------------------------------------------------------------------------------------------------------------}
// VP Functions / Methods
//---------------------------------------------------------------------------------------------------------------------{

f_drawLineX(_x1, _y1, _x2, _y2, _xloc, _extend, _color, _style, _width) =>
    var id = line.new(_x1, _y1, _x2, _y2, _xloc, _extend, _color, _style, _width)
    line.set_xy1(id, _x1, _y1)
    line.set_xy2(id, _x2, _y2)
    line.set_color(id, _color)

f_drawLabelX(_x, _y, _text, _color, _style, _textcolor, _size, _tooltip) =>
    var lb = label.new(_x, _y, _text, xloc.bar_index, yloc.price, _color, _style, _textcolor, _size, text.align_left, _tooltip)
    lb.set_xy(_x, _y)
    lb.set_text(_text)
    lb.set_tooltip(_tooltip)
    lb.set_textcolor(_textcolor)

getData(_ltf) => request.security_lower_tf(syminfo.tickerid, _ltf, bar.new(), ignore_invalid_timeframe = true)

f_gTF(_d) =>
    int tfInMs = timeframe.in_seconds(timeframe.period)
    int  mInMS = 60

    if _d == 2
        switch
            tfInMs <                 30  =>  '1S'
            tfInMs <          1 * mInMS  =>  '5S'

            tfInMs <=        15 * mInMS  =>   '1'
            tfInMs <=        60 * mInMS  =>   '5'
            tfInMs <=       240 * mInMS  =>  '15'
            tfInMs <=      1440 * mInMS  =>  '60'
            => 'D'

    else if _d == 1
        switch
            tfInMs <                 15  =>  '1S'
            tfInMs <                 30  =>  '5S'
            tfInMs <          1 * mInMS  => '15S'

            tfInMs <=         5 * mInMS  =>   '1'
            tfInMs <=        15 * mInMS  =>   '5'
            tfInMs <=        60 * mInMS  =>  '15'
            tfInMs <=       240 * mInMS  =>  '60'
            tfInMs <=      1440 * mInMS  => '240'
            => 'D'

f_gTS(_t) =>
    switch _t
        'Tiny'   => size.tiny
        'Small'  => size.small
        'Normal' => size.normal
        => size.auto

f_crossingLevelX(_price, _level) =>
    (_level > _price and _level < _price[1]) or (_level < _price and _level > _price[1])

alarm(_message) =>
    alert(syminfo.ticker + ' ' + _message + ', price ' + str.tostring(close, format.mintick) + ', timeframe ' + timeframe.period)

//---------------------------------------------------------------------------------------------------------------------}
// Variables
//---------------------------------------------------------------------------------------------------------------------{

// IFVG Variables
var bull_fvg_ary = array.new<fvg>(na) // FVG Data, Not all will be Drawn
var bear_fvg_ary = array.new<fvg>(na)

var bull_inv_ary = array.new<fvg>(na) // Inversion Data, All will be Drawn
var bear_inv_ary = array.new<fvg>(na)

// VP Variables
var barData bD = barData.new(
     array.new <float> (na),
     array.new <float> (na),
     array.new <float> (na),
     array.new <bool>  (na),
     array.new <int>   (na)
 )

volData vD = volData.new(
     array.new <float> (vpNR, 0.),
     array.new <float> (vpNR, 0.),
     array.new <float> (vpNR, 0.)
 )

var tVP VP = tVP.new(
     array.new<box>         (na),
     array.new<chart.point> (na),
     polyline.new           (na), na, na, na, na
 )

var tVH VH = tVH.new(
     array.new<line>        (na),
     array.new<chart.point> (na),
     polyline.new           (na)
 )

bar b = bar.new()
bar [] ltfBD = array.new<bar> (1, bar.new())

var float pHST = na
var float pLST = na
var string ltf = na

//---------------------------------------------------------------------------------------------------------------------}
// Delete drawings
//---------------------------------------------------------------------------------------------------------------------{
for boxes in box.all
    box.delete(boxes)

for lines in line.all
    line.delete(lines)

for labels in label.all
    label.delete(labels)

//---------------------------------------------------------------------------------------------------------------------}
// IFVG Detection
//---------------------------------------------------------------------------------------------------------------------{
atr = nz(ta.atr(200)*atr_multi, ta.cum(high - low) / (bar_index+1))

fvg_up = (low > high[2]) and (close[1] > high[2])
fvg_down = (high < low[2]) and (close[1] < low[2])

if fvg_up and math.abs(low-high[2]) > atr
    array.push(bull_fvg_ary,fvg.new(time[1], low, time, high[2], math.avg(low,high[2]), 1, 0,array.new<lab>(na),na))

if fvg_down and math.abs(low[2]-high) > atr
    array.push(bear_fvg_ary,fvg.new(time[1], low[2], time, high, math.avg(high,low[2]),-1 ,0,array.new<lab>(na),na))

//---------------------------------------------------------------------------------------------------------------------}
// VP Calculations
//---------------------------------------------------------------------------------------------------------------------{

nzV  = nz(b.v)
vSMA = ta.sma(nzV, vmaL)

rpS  = f_gTS(rpLS)
ppLS:= f_gTS(ppLS)

tPOS = lcDB == 'Top Right' ? position.top_right
     : lcDB == 'Middle Right' ? position.middle_right
     : position.bottom_left

if time == chart.left_visible_bar_time
    VP.sI := b.i

if vpRL
    vpLN := last_bar_index - VP.sI

if b.i == last_bar_index - vpLN
    VP.sI   := b.i
    pLST := b.l
    pHST := b.h
else if b.i > last_bar_index - vpLN
    pLST := math.min(b.l, pLST)
    pHST := math.max(b.h, pHST)

if vpLN <= 200
    ltf := f_gTF(2)
    ltfBD := getData(f_gTF(2))
else if vpLN <= 700
    ltf := f_gTF(1)
    ltfBD := getData(f_gTF(1))
else
    ltf := 'Chart'
    ltfBD := array.new<bar> (1, bar.new(b.o, b.h, b.l, b.c, b.v))

if barstate.ishistory and (b.i >= last_bar_index - vpLN) and b.i < last_bar_index and ltfBD.size() > 0

    if ltfBD.size() > 0 and not na(nz(ltfBD.get(0).v))
        for i = 0 to ltfBD.size() - 1
            bD.bh.push(ltfBD.get(i).h)
            bD.bl.push(ltfBD.get(i).l)
            bD.bv.push(ltfBD.get(i).v)

            if vsPT
                bD.bp.push(ltfBD.get(i).c > ltfBD.get(i).o)
            else
                bD.bp.push(ltfBD.get(i).c - ltfBD.get(i).l > ltfBD.get(i).h - ltfBD.get(i).c)

        bD.bn.push(ltfBD.size())

pSTP = (pHST - pLST) / vpNR

if barstate.islast and ltfBD.size() > 0

    if VP.vp.size() > 0
        for i = 0 to VP.vp.size() - 1
            box.delete(VP.vp.shift())

    if bD.bn.size() > vpLN
        qt = bD.bn.shift()
        for i = 0 to qt - 1
            bD.bh.shift()
            bD.bl.shift()
            bD.bv.shift()
            bD.bp.shift()

    VP.pPC.clear()
    VP.dPC.delete()

    if ltfBD.size() > 0 and not na(nz(ltfBD.get(0).v))
        for i = 0 to ltfBD.size() - 1
            bD.bh.push(ltfBD.get(i).h)
            bD.bl.push(ltfBD.get(i).l)
            bD.bv.push(ltfBD.get(i).v)

            if vsPT
                bD.bp.push(ltfBD.get(i).c > ltfBD.get(i).o)
            else
                bD.bp.push(ltfBD.get(i).c - ltfBD.get(i).l > ltfBD.get(i).h - ltfBD.get(i).c)

        bD.bn.push(ltfBD.size())

    bI  = math.min(vpLN, bar_index, 4999)
    bSZ = 0
    aSZ = bD.bv.size()

    for aI = 0 to aSZ - 1

        i = 0
        for pLL = pLST to pHST - pSTP by pSTP

            lH = bD.bh.get(aI)
            lL = bD.bl.get(aI)
            lV = bD.bv.get(aI)

            if lH >= pLL and lL < pLL + pSTP

                vPOR = if lL >= pLL and lH > pLL + pSTP
                    (pLL + pSTP - lL) / (lH - lL)
                else if lH <= pLL + pSTP and lL < pLL
                    (lH - pLL) / (lH - lL)
                else if lL >= pLL and lH <= pLL + pSTP
                    1
                else
                    0

                vD.vt.set(i, vD.vt.get(i) + lV * vPOR)

                if bD.bp.get(aI)
                    vD.vb.set(i, vD.vb.get(i) + lV * vPOR)
            i += 1

        if pcSH == 'Developing POC' and bI >= 0 and vpLN - bI >= 0 and vpLN - bI < bD.bn.size()
            if aI == bD.bn.get(vpLN - bI)
                VP.pPC.push(chart.point.from_index(b.i[bI], math.avg(b.h[bI], b.l[bI])))
                VP.pPC.push(chart.point.from_index(b.i[bI] + 1, pLST + (vD.vt.indexof(vD.vt.max()) + .5) * pSTP))
                bSZ += bD.bn.get(vpLN - bI)
                bI  -= 1
            else if aI == (bSZ + bD.bn.get(vpLN - bI)) and bSZ != 0
                VP.pPC.push(chart.point.from_index(b.i[bI] + 1, pLST + (vD.vt.indexof(vD.vt.max()) + .5) * pSTP))
                bSZ += bD.bn.get(vpLN - bI)
                bI  -= 1
            else if bI == 0
                VP.pPC.push(chart.point.from_index(b.i[bI] + 1, pLST + (vD.vt.indexof(vD.vt.max()) + .5) * pSTP))
                bSZ += bD.bn.get(vpLN - bI)

    VP.dPC := polyline.new(VP.pPC, false, false, xloc.bar_index, pocC, color(na), line.style_solid, pocW)

    for i = 0 to vpNR - 1
        bbp = 2 * vD.vb.get(i) - vD.vt.get(i)
        vD.vd.set(i, vD.vd.get(i) + bbp * (bbp > 0 ? 1 : -1) )

    VP.pcL := vD.vt.indexof(vD.vt.max())
    ttV     = vD.vt.sum() * vpVA
    va      = vD.vt.get(VP.pcL)
    VP.laP := VP.pcL
    VP.lbP := VP.pcL

    for _ = 0 to 1000
        if va >= ttV or (VP.lbP == 0 and VP.laP == vpNR - 1)
            break

        vaP = 0.
        if VP.laP < vpNR - 1
            vaP := vD.vt.get(VP.laP + 1)

        vbP = 0.
        if VP.lbP > 0
            vbP := vD.vt.get(VP.lbP - 1)

        if vaP >= vbP
            va  += vaP
            VP.laP += 1
        else
            va  += vbP
            VP.lbP -= 1

    vaH = pLST + (VP.laP + 1.) * pSTP
    poc = pLST + (VP.pcL + .5) * pSTP
    vaL = pLST + (VP.lbP + .0) * pSTP
    pLN = vpLN > 360 ? 360 : vpLN

    if vahS
        f_drawLineX(VP.sI, vaH, vpRT ? (vpSH ? int((pLN * vpWD + vpHO)) : spSH ? vpHO : 0) + last_bar_index : last_bar_index, vaH, xloc.bar_index, extend.none, vahC, line.style_solid, vahW)

    if pcSH == 'Last (Line)'
        f_drawLineX(VP.sI, poc, last_bar_index, poc, xloc.bar_index, extend.none, pocC, line.style_solid, pocW)

    if vlSH
        f_drawLineX(VP.sI, vaL, vpRT ? (vpSH ? int((pLN * vpWD + vpHO)) : spSH ? vpHO : 0) + last_bar_index : last_bar_index, vaL, xloc.bar_index, extend.none, valC, line.style_solid, valW)

    if vaBG
        VP.vp.push(box.new(VP.sI, vaL, last_bar_index, vaH, vBGC, 1, line.style_dotted, bgcolor = vBGC))

    if vpBG
        VP.vp.push(box.new(VP.sI, pLST, last_bar_index, pHST, bgC, 1, line.style_dotted, bgcolor = bgC))

    if vpLV
        f_drawLabelX(vpRT ? (vpSH ? int((pLN * vpWD + vpHO)) : spSH ? vpHO : 0) + last_bar_index : last_bar_index, pHST,
                     str.tostring(pHST, format.mintick), color.new(chart.fg_color, 89), vpRT ? not vpSH and not spSH ? label.style_label_left : label.style_label_down : label.style_label_left, chart.fg_color, rpS,
                     'Profile High')

        f_drawLabelX(vpRT ? (vpSH ? int((pLN * vpWD + vpHO)) : spSH ? vpHO : 0) + last_bar_index + (spSH ? int(vD.vd.max() / vD.vt.max() * pLN * vpWD) : 0) : last_bar_index, vaH,
                     str.tostring(vaH, format.mintick), color.new(vahC, 89), label.style_label_left, vahC, rpS, 'Value Area High')

        f_drawLabelX(vpRT ? (vpSH ? int((pLN * vpWD + vpHO)) : spSH ? vpHO : 0) + last_bar_index + (spSH ? int(vD.vd.max() / vD.vt.max() * pLN * vpWD) : 0) : last_bar_index, poc,
                     str.tostring(poc, format.mintick), color.new(pocC, 89), label.style_label_left, pocC, rpS, 'Point of Control')

        f_drawLabelX(vpRT ? (vpSH ? int((pLN * vpWD + vpHO)) : spSH ? vpHO : 0) + last_bar_index + (spSH ? int(vD.vd.max() / vD.vt.max() * pLN * vpWD) : 0) : last_bar_index, vaL,
                     str.tostring(vaL, format.mintick), color.new(valC, 89), label.style_label_left, valC, rpS, 'Value Area Low')

        f_drawLabelX(vpRT ? (vpSH ? int((pLN * vpWD + vpHO)) : spSH ? vpHO : 0) + last_bar_index : last_bar_index, pLST,
                     str.tostring(pLST, format.mintick), color.new(chart.fg_color, 89), vpRT ? not vpSH and not spSH ? label.style_label_left : label.style_label_up : label.style_label_left, chart.fg_color, rpS,
                     'Profile Low')

    if vpST
        table change = table.new(tPOS, 2, 10, border_width = 3)
        tC = chart.fg_color
        table.cell(change, 0, 0, 'Profile High', text_color = tC, bgcolor = color.new(tC, 80), text_halign = text.align_left, text_size = ppLS,
                     tooltip = 'profile high - ' + str.tostring(pHST, format.mintick) + '\n %' + str.tostring((pHST - pLST) / pLST * 100, '#.##') + ' higher than the profile low (' + str.tostring(pLST, format.mintick) + ')')
        table.cell(change, 1, 0, str.tostring(pHST, format.mintick), text_color = tC, bgcolor = color.new(tC, 80), text_halign = text.align_right, text_size = ppLS)
        table.cell(change, 0, 1, 'Value Area High', text_color = tC, bgcolor = color.new(tC, 80), text_halign = text.align_left, text_size = ppLS)
        table.cell(change, 1, 1, str.tostring(vaH, format.mintick), text_color = tC, bgcolor = color.new(tC, 80), text_halign = text.align_right, text_size = ppLS)
        table.cell(change, 0, 2, 'Point of Control', text_color = tC, bgcolor = color.new(tC, 80), text_halign = text.align_left, text_size = ppLS)
        table.cell(change, 1, 2, str.tostring(poc, format.mintick), text_color = tC, bgcolor = color.new(tC, 80), text_halign = text.align_right, text_size = ppLS)
        table.cell(change, 0, 3, 'Value Area Low', text_color = tC, bgcolor = color.new(tC, 80), text_halign = text.align_left, text_size = ppLS)
        table.cell(change, 1, 3, str.tostring(vaL, format.mintick), text_color = tC, bgcolor = color.new(tC, 80), text_halign = text.align_right, text_size = ppLS)
        table.cell(change, 0, 4, 'Profile Low', text_color = tC, bgcolor = color.new(tC, 80), text_halign = text.align_left, text_size = ppLS,
                     tooltip = 'profile low - '  + str.tostring(pLST, format.mintick) + '\n %' + str.tostring((pHST - pLST) / pHST * 100, '#.##') + ' lower than the profile high (' + str.tostring(pHST, format.mintick) + ')')
        table.cell(change, 1, 4, str.tostring(pLST, format.mintick), text_color = tC, bgcolor = color.new(tC, 80), text_halign = text.align_right, text_size = ppLS)
        table.cell(change, 0, 5, 'Total Volume\nin VP Range', text_color = tC, bgcolor = color.new(tC, 80), text_halign = text.align_left, text_size = ppLS, tooltip = 'total traded volume in vp range')
        table.cell(change, 1, 5, str.tostring(vD.vt.sum(), format.volume), text_color = tC, bgcolor = color.new(tC, 80), text_halign = text.align_right, text_size = ppLS)
        table.cell(change, 0, 6, 'Avg Volume/Bar', text_color = tC, bgcolor = color.new(tC, 80), text_halign = text.align_left, text_size = ppLS, tooltip = 'average traded volume per bar in vp range')
        table.cell(change, 1, 6, str.tostring(vD.vt.sum() / (vpLN + 1), format.volume), text_color = tC, bgcolor = color.new(tC, 80), text_halign = text.align_right, text_size = ppLS)
        table.cell(change, 0, 7, 'Volume MA (' + str.tostring(vmaL) + ')', text_color = tC, bgcolor = color.new(tC, 80), text_halign = text.align_left, text_size = ppLS, tooltip = 'volume moving average')
        table.cell(change, 1, 7, str.tostring(vSMA, format.volume), text_color = tC, bgcolor = color.new(tC, 80), text_halign = text.align_right, text_size = ppLS)
        table.cell(change, 0, 8, 'Number of Bars', text_color = tC, bgcolor = color.new(tC, 80), text_halign = text.align_left, text_size = ppLS, tooltip = 'number of chart bars : ' + str.tostring(vpLN) + ' + 1 (developping bar)')
        table.cell(change, 1, 8, str.tostring(vpLN + 1), text_color = tC, bgcolor = color.new(tC, 80), text_halign = text.align_right, text_size = ppLS)
        table.cell(change, 0, 9, 'Data From', text_color = tC, bgcolor = color.new(tC, 80), text_halign = text.align_left, text_size = ppLS,
                     tooltip = 'volume data fetching logic\n\nif #bars <= 200\n -two lower timeframes\nelse if #bars <= 700\n -one lower timeframe\nelse\n -chart timeframe')
        table.cell(change, 1, 9, ltf + ' TF', text_color = tC, bgcolor = color.new(tC, 80), text_halign = text.align_right, text_size = ppLS)

    for i = 0 to vpNR - 1

        if vpSH
            sBI = vpRT ? int((pLN * vpWD + vpHO)) + int(last_bar_index - vD.vb.get(i) / vD.vt.max() * pLN * vpWD) : VP.sI
            eBI = vpRT ? int((pLN * vpWD + vpHO)) + last_bar_index : int(sBI + vD.vb.get(i) / vD.vt.max() * pLN * vpWD)
            VP.vp.push(box.new(sBI, pLST + (i + .1) * pSTP, eBI, pLST + (i + .9) * pSTP, color(na), bgcolor = i >= VP.lbP and i <= VP.laP ? vaUC : vpUC))

            sBI := vpRT ? sBI : eBI
            eBI := vpRT ? sBI - int( (vD.vt.get(i) - vD.vb.get(i)) / vD.vt.max() * pLN * vpWD) : sBI + int( (vD.vt.get(i) - vD.vb.get(i)) / vD.vt.max() * pLN * vpWD)
            VP.vp.push(box.new(sBI, pLST + (i + .1) * pSTP, eBI, pLST + (i + .9) * pSTP, color(na), bgcolor = i >= VP.lbP and i <= VP.laP ? vaDC : vpDC))

        if spSH
            sBI = vpRT ? (vpSH ? int((pLN * vpWD + vpHO)) : vpHO) + int(last_bar_index + vD.vd.get(i) / vD.vt.max() * pLN * vpWD) : VP.sI
            eBI = vpRT ? (vpSH ? int((pLN * vpWD + vpHO)) : vpHO) + last_bar_index : vpRL ? int(sBI + vD.vd.get(i) / vD.vt.max() * pLN * vpWD) : int(sBI - vD.vd.get(i) / vD.vt.max() * pLN * vpWD)

            bbp = 2 * vD.vb.get(i) - vD.vt.get(i)
            VP.vp.push(box.new(sBI, pLST + (i + .1) * pSTP, eBI, pLST + (i + .9) * pSTP, color(na), bgcolor = bbp > 0 ? spUC : spDC))

        if sdSH and vD.vt.get(i) / vD.vt.max() < sdTH
            sdC = pLST + (i + 0.50) * pSTP > pLST + (VP.pcL + .5) * pSTP ? sdSC : sdDC
            VP.vp.push(box.new(b.i[math.min(vpLN, bar_index, 4999)], pLST + (i + 1.) * pSTP, b.i, pLST + (i + .0) * pSTP, color(na), bgcolor = sdC ))

//---------------------------------------------------------------------------------------------------------------------}
// Volume Histogram Calculations
//---------------------------------------------------------------------------------------------------------------------{

pHSTv = ta.highest(b.h, math.min(vpLN < 497 ? vpLN : 496, bar_index + 1))
pLSTv = ta.lowest (b.l, math.min(vpLN < 497 ? vpLN : 496, bar_index + 1))
vHST  = ta.highest(nzV, math.min(vpLN < 497 ? vpLN : 496, bar_index + 1))
vMAR  = nzV / vSMA

if barstate.islast and not na(nzV) and vhSH and vSMA > 0

    pCHR = (pHSTv - pLSTv) / pHSTv

    if VH.vh.size() > 0
        for i = 0 to VH.vh.size() - 1
            line.delete(VH.vh.shift())

    VH.pMA.clear()
    VH.vMA.delete()

    for bI = 0 to math.min(vpLN, bar_index, 4999)

        if VH.vh.size() < 500
            VH.vh.push(line.new(
                 b.i[bI],  vhLP ? pHST + pHSTv * pCHR * vhVO : pLST - pLSTv * pCHR * vhVO,
                 b.i[bI], (vhLP ? pHST + pHSTv * pCHR * vhVO : pLST - pLSTv * pCHR * vhVO) * (1 + ( vhLP ? 1 : -1) * nzV[bI] / vHST * pCHR / vhHT),
                 xloc.bar_index, extend.none, vhUC, line.style_solid, 1))

            if vmaS and not na(vSMA[bI])
                VH.pMA.push(chart.point.from_index(b.i[bI], vhLP ? pHST + pHSTv * pCHR * vhVO : pLST - pLSTv * pCHR * vhVO))

    VH.vMA := polyline.new(VH.pMA, false, false, xloc.bar_index, vmaC, color(na), line.style_solid, 1)

//---------------------------------------------------------------------------------------------------------------------}
// Volume Weighted Colored Bars
//---------------------------------------------------------------------------------------------------------------------{

barcolor(vwcb and not na(nzV) ? nzV > vSMA * upTH ? b.o < b.c ? #006400 : #910000 : nzV < vSMA * dnTH ? b.o < b.c ? #7FFFD4 : #FF9800 : na : na, title='Volume Weighted Colored Bars', editable = false)

//---------------------------------------------------------------------------------------------------------------------}
// Running Functions
//---------------------------------------------------------------------------------------------------------------------{
// FVG_Data -> Inversion_Data -> Chart
fvg_manage(bull_fvg_ary,bull_inv_ary)
fvg_manage(bear_fvg_ary,bear_inv_ary)

bear_signal = inv_manage(bull_inv_ary)
bull_signal = inv_manage(bear_inv_ary)

if barstate.islast
    send_it(bull_inv_ary)
    send_it(bear_inv_ary)

//---------------------------------------------------------------------------------------------------------------------}
// EMAs Calculations
//---------------------------------------------------------------------------------------------------------------------{
shortest = ta.ema(close, ema1_length)
short = ta.ema(close, ema2_length)
longer = ta.ema(close, ema3_length)
longest = ta.ema(close, ema4_length)

plot(shortest, color=ema1_color, title="EMA 1")
plot(short, color=ema2_color, title="EMA 2")
plot(longer, color=ema3_color, title="EMA 3")
plot(longest, color=ema4_color, title="EMA 4")

//---------------------------------------------------------------------------------------------------------------------}
// Alert Options
//---------------------------------------------------------------------------------------------------------------------{
alertcondition(bull_signal, "Señal BULL")
alertcondition(bear_signal, "Señal BEAR")

if f_crossingLevelX(b.c[1], pLST + (VP.pcL + .50) * pSTP) and pcSH != 'None'
    alarm('price action ' + (b.c[1] > pLST + (VP.pcL + .50) * pSTP ? 'crossed above ' : 'crossed below ') + 'the point of control line')

if f_crossingLevelX(b.c[1], pLST + (VP.laP + 1.00) * pSTP) and vahS
    alarm('price action ' + (b.c[1] > pLST + (VP.laP + 1.00) * pSTP ? 'crossed above ' : 'crossed below ') + 'the value area high line')

if f_crossingLevelX(b.c[1], pLST + (VP.lbP + 0.00) * pSTP) and vlSH
    alarm('price action ' + (b.c[1] > pLST + (VP.lbP + 0.00) * pSTP ? 'crossed above ' : 'crossed below ') + 'the value area low line')

if nzV > vSMA * upTH and (vwcb or vhSH)
    alarm('high volume detected')

if nzV > vSMA * 4.669 and (vwcb or vhSH)
    alarm('watch out volume spike detected, may be a sign of exhaustion')
